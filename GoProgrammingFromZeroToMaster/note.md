
### Go发展史
- 引入对WebAssembly的支持，让Gopher可以使用Go语言来开发Web应用；
- 提供了GOPRIVATE变量，用于指示哪些仓库下的module是私有的，即既不需要通过GOPROXY下载，也不需要通过GOSUMDB去验证其校验和。
- 在标准库中增加errors.Is和errors.As函数来解决错误值（error value）的比较判定问题，增加errors.Unwrap函数来解决error的展开（unwrap）问题。
- GODEBUG环境变量支持跟踪包init函数的消耗；
- 新增io/fs包，建立Go原生文件系统抽象；新增embed包，作为在二进制文件中嵌入静态资源文件的官方方案。

#### 开源社区对Go版本的选择策略
- 更近最新版本，像kubernetes
- 使用2个发布周期前的版本，像docker
- 使用最新版本之前的版本

### Go设计哲学

#### Simplicity

因此，今天呈现在我们眼前的是这样的Go语言：
- 简洁、常规的语法（不需要解析符号表），它仅有25个关键字；
- 内置垃圾收集，降低开发人员内存管理的心智负担；
- 没有头文件；
- 显式依赖（package）；没有循环依赖（package）；
- 常量只是数字；
- 首字母大小写决定可见性；
- 任何类型都可以拥有方法（没有类）；
- 没有子类型继承（没有子类）；
- 没有算术转换；
- 接口是隐式的（无须implements声明）；
- 方法就是函数；
- 接口只是方法集合（没有数据）；
- 方法仅按名称匹配（不是按类型）；
- 没有构造函数或析构函数；
- n++和n--是语句，而不是表达式；没有++n和--n；
- 赋值不是表达式；
- 在赋值和函数调用中定义的求值顺序（无“序列点”概念）；

-3.2　偏好组合，正交解耦
Go采用了组合的方式，也是唯一的方法
Go语言提供的最为直观的组合的语法元素是类型嵌入（type embedding）

```go
// $GOROOT/src/sync/pool.go
type poolLocal struct {
    private interface{}
    shared  []interface{}
    Mutex
    pad     [128]byte
}
```
interface是Go语言中真正的“魔法”，是Go语言的一个创新设计，它只是方法集合，且与实现者之间的关系是隐式的，它让程序各个部分之间的耦合降至最低，同时是连接程序各个部分的“纽带”。隐式的interface实现会不经意间满足依赖抽象、里氏替换、接口隔离等设计原则，这在其他语言中是需要很刻意的设计谋划才能实现的，但在Go interface看来，一切却是自然而然的。


类型嵌套是垂直扩展，接口组合是水平扩展，各自独立而又组合实现了某种功能



Go的设计者敏锐地把握了CPU向多核方向发展的这一趋势，在决定不再使用C++而去创建一门新语言的时候，果断将面向多核、原生内置并发支持作为新语言的设计原则之一。

并发和并行
并发是有关结构的，它是一种将一个程序分解成多个小片段并且每个小片段都可以独立执行的程序设计方法；并发程序的小片段之间一般存在通信联系并且通过通信相互协作。并行是有关执行的，它表示同时进行一些计算任务。
并发是一种程序设计，他让并行成为可能
并发可以充分利用多核，让不同的任务跑在不同的核上，提高利用率和效率，而并行及时在多核情况下，也无法支持

搬书的并发方案 vs.搬书的并行方案(https://www.youtube.com/watch?v=oV9rvDllKEg)

一个loadbalancer的例子(https://go.dev/talks/2012/waza.slide#1)

程序构建慢；失控的依赖管理；开发人员使用编程语言的不同子集（比如C++支持多范式，这样有些人用OO，有些人用泛型）；代码可理解性差（代码可读性差、文档差等）；功能重复实现；升级更新消耗大；实现自动化工具难度高；版本问题；跨语言构建问题。

在Go语言最初设计阶段就将解决工程问题作为Go的设计原则之一去考虑Go语法、工具链与标准库的设计

比如Rob Pike就曾谈到，Go当初之所以没有使用Python那样的代码缩进而是选择了与C语言相同的大括号来表示程序结构，是因为他们经过调查发现，虽然Python的缩进结构在构建小规模程序时的确很方便，但是当代码库变得更大的时候，缩进式的结构非常容易出错。从工程的安全性和可靠性角度考虑，Go团队最终选择了大括号代码块结构。

（3）工具链开发人员在做工程的过程中需要使用工具。而Go语言提供了十分全面、贴心的编程语言官方工具链，涵盖了编译、编辑、依赖获取、调试、测试、文档、性能剖析等的方方面面。
构建和运行：go build/go run
依赖包查看与获取：go list/go get/go mod xx
编辑辅助格式化：go fmt/gofmt
文档查看：go doc/godoc
单元测试/基准测试/测试覆盖率：go test
代码静态分析：go vet
性能剖析与跟踪结果查看：go tool pprof/go tool trace
升级到新Go版本API的辅助工具：go tool fix
报告Go语言bug：go bug


编程语言影响编程思维，或者说每种编程语言都有属于自己的原生编程思维

#### standard project

![image-20240207092830690](C:\Users\xjshen\AppData\Roaming\Typora\typora-user-images\image-20240207092830690.png)

#### lib project

![image-20240207093006924](C:\Users\xjshen\AppData\Roaming\Typora\typora-user-images\image-20240207093006924.png)

带internal的Go库项目结构

```
$tree -F ./chapter2/sources/GoLibProj
GoLibProj
├── LICENSE
├── Makefile
├── README.md
├── go.mod
├── internal/
│  ├── ilib1/
│  └── ilib2/
├── lib.go
├── lib1/
│  └── lib1.go
└── lib2/
      └── lib2.go
```

https://github.com/golang-standards/project-layout/issues/117#issuecomment-828503689

作为Go开发人员，请在提交代码前使用gofmt进行格式化。
一个好笑话，如果你必须解释它，那就不好笑了。好的命名也类似。
因此如果要寻找良好命名的示范，Go标准库是一个不错的地方。
要想做好Go标识符的命名（包括对包的命名），至少要遵循两个原则：
- 简单且一致；
- 利用上下文辅助命名。
Go语言建议，包名应尽量与包导入路径（import path）的最后一个路径分段保持一致。
在Go中变量分为包级别的变量和局部变量（函数或方法内的变量）。函数或方法的参数、返回值都可以被视为局部变量。
- 循环和条件变量多采用单个字母命名（具体见上面的统计数据）；
- 函数/方法的参数和返回值变量以单个单词或单个字母为主；
- 由于方法在调用时会绑定类型信息，因此方法的命名以单个单词为主；
- 函数多以多单词的复合词进行命名；
- 类型多以多单词的复合词进行命名。

Go语言命名惯例深受C语言的影响，这与Go语言之父有着深厚的C语言背景不无关系。Go语言追求简单一致且利用上下文辅助名字信息传达的命名惯例，如果你刚从其他语言转向Go，这可能会让你感到不适应，但这就是Go语言文化的一部分，也许等你编写的Go代码达到一定的量，你就能理解这种命名惯例的好处了。
